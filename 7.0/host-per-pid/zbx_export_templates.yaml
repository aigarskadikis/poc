zabbix_export:
  version: '7.0'
  template_groups:
    - uuid: bc222ed8fc494eb5851b7f65b54af37e
      name: pidmon
  host_groups:
    - uuid: 7f382af7c7b84f3cbafc386c3cd40e59
      name: PrID
  templates:
    - uuid: 43c25f57edaa409b8624e6657d7b7281
      template: ppid
      name: ppid
      groups:
        - name: pidmon
      items:
        - uuid: a4becf905f2d486e840a730cd6c9c3e5
          name: 'process.get raw'
          key: 'proc.get[,,,process]'
          delay: '{$SCH:delay}'
          value_type: LOG
          trends: '0'
          preprocessing:
            - type: JSONPATH
              parameters:
                - '$..[?(!(@.[''ppid''] == 2))]'
              error_handler: CUSTOM_VALUE
              error_handler_params: '[]'
            - type: JSONPATH
              parameters:
                - '$..[?(@.["ppid"] > 0)]'
              error_handler: CUSTOM_VALUE
              error_handler_params: '[]'
            - type: JAVASCRIPT
              parameters:
                - |
                  var lld = [];
                  var lines = JSON.parse(value);
                  for (i = 0; i < lines.length; i++) {
                    var row = {};
                    row["pid"] = lines[i].pid;
                    row["ppid"] = lines[i].ppid;
                    row["name"] = lines[i].name;
                    row["cmdline"] = lines[i].cmdline;
                    lld.push(row);
                  }
                  
                  return JSON.stringify(lld);
            - type: JAVASCRIPT
              parameters:
                - |
                  // sort
                  function sortJson(obj) {
                    if (Object.prototype.toString.call(obj) === '[object Object]') {
                      var sortedObj = {};
                      var keys = [];
                      for (var key in obj) {
                        if (obj.hasOwnProperty(key)) {
                          keys.push(key);
                        }
                      }
                      keys.sort();
                      for (var i = 0; i < keys.length; i++) {
                        var k = keys[i];
                        sortedObj[k] = sortJson(obj[k]);
                      }
                      return sortedObj;
                    } else if (Object.prototype.toString.call(obj) === '[object Array]') {
                      var sortedArray = [];
                      for (var j = 0; j < obj.length; j++) {
                        sortedArray.push(sortJson(obj[j]));
                      }
                      return sortedArray.sort(function (a, b) {
                        return JSON.stringify(a) > JSON.stringify(b) ? 1 : -1;
                      });
                    } else {
                      return obj;
                    }
                  }
                  
                  return JSON.stringify(sortJson(JSON.parse(value)));
                  
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 1d
        - uuid: ce04e585829147b5a1a3687835c3ffb9
          name: 'process path debug'
          type: DEPENDENT
          key: process.path.debug
          delay: '0'
          value_type: LOG
          trends: '0'
          preprocessing:
            - type: JAVASCRIPT
              parameters:
                - |
                  //delay = {$SCH:delay};
                  // delay = 300;
                  
                  var lld = [];
                  var lines = JSON.parse(value);
                  for (i = 0; i < lines.length; i++) {
                    Zabbix.Log(3, JSON.stringify(lines[i]));
                    var row = {};
                    row["pid"] = lines[i].pid;
                    row["ppid"] = lines[i].ppid;
                    row["name"] = lines[i].name;
                  
                   // row["cmdline"] = lines[i].cmdline.match(/pidfile/) ? 'pod ' +
                   //   lines[i].cmdline.match(/pidfile....(.*)...exit.dir/)[1] :
                   //   lines[i].cmdline.replace(/ \[[^\]]+\]$/, '').replace(/^.*\//gm, '').replace(/[^a-zA-Z0-9\. ]/g, '');
                  
                    // special formating rule
                    row["host"] = '';
                   //if (lines[i].cmdline.match(/pidfile/)) {
                   //   row["host"] = 'pod ' + lines[i].cmdline.replace(/\s+$/, '').match(/pidfile....(.*)...exit.dir/)[1];
                   // } else if (lines[i].cmdline.match(/postgres: \S+ \S+ [0-9.]+/)) {
                    //  row["host"] = lines[i].cmdline.replace(/\s+$/, '').match(/(postgres: \S+ \S+ [0-9.]+)/)[1].replace(/[^a-zA-Z0-9\. ]/g, '');
                   // } else {
                   //   row["host"] = lines[i].cmdline.replace(/\s+$/, '').replace(/ \[[^\]]+\]$/, '').replace(/^.*\//gm, '').replace(/[^a-zA-Z0-9\. ]/g, '');
                   // }
                  
                  
                    lld.push(row);
                  }
                  
                  var processes = lld;
                  
                  // Create a mapping from pid to process
                  var pidMap = {};
                  for (var i = 0; i < processes.length; i++) {
                    pidMap[processes[i].pid] = processes[i];
                  }
                  
                  // Function to build full path from root to a given pid
                  function buildPath(pid) {
                    var path = [];
                    while (pidMap[pid]) {
                      path.unshift(pid);
                      pid = pidMap[pid].ppid;
                    }
                    path.unshift(pid); // Add the root (e.g., 1)
                    return path.join("/");
                  }
                  
                  // Find leaf nodes (those not being a parent of any other)
                  var parentSet = {};
                  for (var i = 0; i < processes.length; i++) {
                    parentSet[processes[i].ppid] = true;
                  }
                  
                  var out = [];
                  for (var i = 0; i < processes.length; i++) {
                    var pid = processes[i].pid;
                    if (!parentSet[pid]) {
                      out.push(buildPath(pid));
                    }
                  }
                  
                  
                  return out.join("\n");
                  
                  
          master_item:
            key: 'proc.get[,,,process]'
        - uuid: 0cb4520bbae54ab4a2ae48acad9a9878
          name: 'process path translated'
          type: DEPENDENT
          key: process.path.translated
          delay: '0'
          value_type: LOG
          trends: '0'
          preprocessing:
            - type: JAVASCRIPT
              parameters:
                - |
                  delay = {$SCH:delay};
                  //delay = 300;
                  
                  var lld = [];
                  var lines = JSON.parse(value);
                  for (i = 0; i < lines.length; i++) {
                    var row = {};
                    row["pid"] = lines[i].pid;
                    row["ppid"] = lines[i].ppid;
                    row["name"] = lines[i].name;
                  
                    row["cmdline"] = lines[i].cmdline.match(/pidfile....(.*)...exit.dir/) ? 'pod ' +
                      lines[i].cmdline.match(/pidfile....(.*)...exit.dir/)[1] :
                      lines[i].cmdline.replace(/ \[[^\]]+\]$/, '').replace(/^.*\//gm, '').replace(/[^a-zA-Z0-9\. ]/g, '');
                  
                  // special formating rule
                   if (lines[i].cmdline.match(/pidfile....(.*)...exit.dir/)) {
                      row["host"] = 'pod ' + lines[i].cmdline.replace(/\s+$/, '').match(/pidfile....(.*)...exit.dir/)[1];
                  }
                  else if (lines[i].cmdline.match(/postgres: \S+ \S+ [0-9.]+/)) {
                    row["host"] = lines[i].cmdline.replace(/\s+$/, '').match(/(postgres: \S+ \S+ [0-9.]+)/)[1].replace(/[^a-zA-Z0-9\. ]/g, '');
                  }
                  else if (lines[i].cmdline.match(/moby..id ([a-f0-9]{64})..address/)) {
                    row["host"] = lines[i].cmdline.match(/moby..id ([a-f0-9]{64})..address/)[1];
                  }
                  else if (lines[i].cmdline.match(/(host.port \S+ .container.ip \S+)/)) {
                    row["host"] = lines[i].cmdline.match(/(host.port \S+ .container.ip \S+)/)[1].replace(/ .container/g, ' container');
                    
                  }
                  else {
                      row["host"] = lines[i].cmdline.replace(/\s+$/, '').replace(/ \[[^\]]+\]$/, '').replace(/^.*\//gm, '').replace(/[^a-zA-Z0-9\. ]/g, '');
                  }
                  
                    lld.push(row);
                  }
                  
                  var processes = lld;
                  
                  // Create a mapping from pid to process
                  var pidMap = {};
                  for (var i = 0; i < processes.length; i++) {
                    pidMap[processes[i].pid] = processes[i];
                  }
                  
                  // Function to build full path from root to a given pid
                  function buildPath(pid) {
                    var path = [];
                    while (pidMap[pid]) {
                      path.unshift(pid);
                      pid = pidMap[pid].ppid;
                    }
                    path.unshift(pid); // Add the root (e.g., 1)
                    return path.join("/");
                  }
                  
                  // Find leaf nodes (those not being a parent of any other)
                  var parentSet = {};
                  for (var i = 0; i < processes.length; i++) {
                    parentSet[processes[i].ppid] = true;
                  }
                  
                  var out = [];
                  for (var i = 0; i < processes.length; i++) {
                    var pid = processes[i].pid;
                    if (!parentSet[pid]) {
                      out.push(buildPath(pid));
                    }
                  }
                  
                  var input = [];
                  for (var i = 0; i < out.length; i++) {
                    //Zabbix.Log(3,out[i])
                    if (out[i].match(/^1\//)) {  input.push(out[i].match(/^1\/(.*)/)[1]); }
                  }
                  
                  // return input;
                  
                  processPidRel = [];
                  
                  for (var i = 0; i < input.length; i++) {
                  
                    // split line into PIDs
                    var translated = '';
                  
                    //Zabbix.Log(3,"input: "+input[i])
                    var fullPath = input[i].split("\/");
                  
                    //Zabbix.Log(3,"full: "+fullPath.join("\n"));
                  
                    for (var f = 0; f < fullPath.length; f++) {
                  
                      // locate process binary name based on pid
                      for (var n = 0; n < lld.length; n++) {
                  
                        // if process ID match
                        if (parseInt(fullPath[f]) === parseInt(lld[n].pid)) {
                  
                          if ( 
                            lld[n].host.match(/^systemd/) || 
                            lld[n].host.match(/^dbusbrokerlaunch/) || 
                            lld[n].host.match(/^dbusbroker/) ||
                            lld[n].host.match(/^sshd/) ||
                            lld[n].host.match(/^volumes/)
                          
                          ) {
                            addToString = lld[n].host.match(/^(\S+)/)[1];
                          } else {
                            addToString = lld[n].host;
                          }
                  
                          if (translated === '') {
                            translated = translated + addToString;
                          } else {
                            translated = translated + '/' + addToString;
                          }
                          //Zabbix.Log(3,"translated: "+translated)
                          lastPid = lld[n].pid;
                  
                        }
                  
                      }
                  
                  
                  
                    }
                  
                    processPidRel.push({'host':translated
                    .replace(/\//gm,' ')
                    .replace(/zabbixserver.*zabbixserver/gm,'zabbixserver')
                    .replace(/zabbixproxy.*zabbixproxy/gm,'zabbixproxy')
                    .replace(/zabbixagentd.*zabbixagentd/gm,'zabbixagentd')
                    .replace(/zabbixagent2.*zabbixagent2/gm,'zabbixagent2')
                    .replace(/zabbixjavagateway.*JavaGateway/gm,'ZabbixJavaGateway')
                    .replace(/sshd.*oCASignatureAlgorithmsecdsasha2nistp256ecdsasha2nistp384ecdsasha2nistp521sshed25519rsasha2256rsasha2512sshrsa/gm,'sshd')
                    .replace(/postgres.*postgres/gm,'postgres')
                    ,'path':translated.replace(/^\//,''),'pid':lastPid,'server':'{$HOST.HOST}'});
                  
                  }
                  
                  
                  
                  // generate all possible timestamps
                  function generateSchedule(batchDelay, offset) {
                      // the perfect second
                      var perfectSecond = offset % 60;
                      // jump
                      var jump = Math.floor(batchDelay / 60);
                      // first minute to kick in
                      var firstkick = Math.floor(offset / 60);
                      var times = [];
                      for (var m = firstkick; m < 60; m += jump) { times.push(m); }
                      return "m" + times.join(',') + "s" + perfectSecond;
                  }
                  var all = [];
                  for (var n = 0; n < delay; n++) { all.push(generateSchedule(delay, n)); }
                  
                  // inject timestamp
                  var outcome = [];
                    for (var n = 0; n < processPidRel.length; n++) {
                  var row = processPidRel[n];
                  row["itstime"] = all[ n % delay ];
                  outcome.push(row);
                  }
                  
                  
                  return JSON.stringify(outcome);
                  
                  
            - type: JAVASCRIPT
              parameters:
                - |
                  // avoid duplicate process names by adding number
                  var data = JSON.parse(value);
                  
                  // Step 1: Count occurrences of each host
                  var hostOccurrences = {};
                  for (var i = 0; i < data.length; i++) {
                      var host = data[i].host;
                      if (hostOccurrences[host] === undefined) {
                          hostOccurrences[host] = 1;
                      } else {
                          hostOccurrences[host]++;
                      }
                  }
                  
                  // Step 2: Modify host names only if duplicates exist
                  var hostCount = {};  // Dictionary to track occurrences
                  for (var i = 0; i < data.length; i++) {
                      var host = data[i].host;
                  
                      if (hostOccurrences[host] > 1) {
                          // If first occurrence, add "1"
                          if (hostCount[host] === undefined) {
                              hostCount[host] = 1;
                              data[i].host = host + " 1";
                          } else {
                              hostCount[host]++;
                              data[i].host = host + " " + hostCount[host];
                          }
                      }
                  }
                  
                  // Print output (Duktape doesn't have console.log, use print)
                  return JSON.stringify(data, null, 2);
                  
          master_item:
            key: 'proc.get[,,,process]'
      discovery_rules:
        - uuid: 9fcdf4e126314dd3a6d8e7d922c33c81
          name: pidpr
          type: DEPENDENT
          key: pidpr
          delay: '0'
          lifetime: 1h
          host_prototypes:
            - uuid: 522909d1d40e437ea9bc1d2500ba604e
              host: '{#SERVER} {#HOST}'
              name: '{#SERVER} {#HOST}'
              inventory_mode: AUTOMATIC
              group_links:
                - group:
                    name: PrID
              group_prototypes:
                - name: 'PIDs/{#SERVER}'
              templates:
                - name: 'ppid PIDs lvl1'
              macros:
                - macro: '{$ITS.TIME}'
                  value: '{#ITS.TIME}'
                - macro: '{$PATH}'
                  value: '{#PATH}'
                - macro: '{$PID}'
                  value: '{#PID}'
              tags:
                - tag: pid
          master_item:
            key: process.path.translated
          lld_macro_paths:
            - lld_macro: '{#HOST}'
              path: '$.[''host'']'
            - lld_macro: '{#ITS.TIME}'
              path: '$.[''itstime'']'
            - lld_macro: '{#PATH}'
              path: '$.[''path'']'
            - lld_macro: '{#PID}'
              path: '$.[''pid'']'
            - lld_macro: '{#SERVER}'
              path: '$.[''server'']'
    - uuid: e8135f83d8284b44baec7c07709359ec
      template: 'ppid PIDs lvl1'
      name: 'ppid PIDs lvl1'
      templates:
        - name: 'proc pid mon'
      groups:
        - name: pidmon
      items:
        - uuid: 5d728c1939c941c6b9fd1b2eb1e2e011
          name: cmdline
          key: 'vfs.file.contents[/proc/{$PID}/cmdline]'
          delay: '0;{$ITS.TIME}'
          history: '0'
          value_type: CHAR
          trends: '0'
          inventory_link: NAME
          preprocessing:
            - type: DISCARD_UNCHANGED_HEARTBEAT
              parameters:
                - 1d
          timeout: 1s
      macros:
        - macro: '{$UPD}'
          value: '0'
